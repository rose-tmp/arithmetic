dp相关内容：
https://www.zhihu.com/question/39948290
https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=100000768&idx=1&sn=86d496e4a1e65c72cddca36977c61eb4&chksm=1bd7fa082ca0731ebc5021cacfb1def56b4c057f8c6debb79253deac7de9687dfa17a6662fae&scene=18#wechat_redirect

动态规划三要素(其中重叠子问题不是必要条件  另外两个是动态规划问题需要满足的条件 即必要条件
    做题的时候可以先大致判断一下是否符合这三点 当然很多也是靠经验积累
    而不是死套这三点条件 还是要积累一些经典的题目作为基础的动态规划知识储备):
        重叠子问题:动态规划思想出现的起初原因就在这里，即达到聪明穷举的目的 重叠子问题不是必要条件 但是如果该性质无法满足，动态规划算法同其他算法相比就不具备优势
        最优子结构(某些问题的特质 并不是dp问题专有的):也就是可以将问题规模缩小，从局部最值推得出全局最值(总分最高和每一科目最高之间的关系)
        无后效性(即可以写出状态方程或者说可以从dp[0...i-1]推出来dp[i])

第一步要明确两点，「状态」和「选择」
第二步要明确dp数组的定义
第三步，根据「选择」，思考状态转移的逻辑

大致框架(可以结合LongestCommonSubsequence中动态规划方法去理解):
    //其中状态就是dp数组的维数
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 择优(选择1，选择2...)




这些题目大致的写题顺序：先写出来暴力递归，然后根据暴力递归中是否存在重复子问题这一现象，存在就改成带备忘录的递归。
                     而能写出来带备忘录的递归的话就可以写出来动态规划解法，因为memo和dp table的含义是相同的

           注：递归怎么样写才最直观呢？不是在脑子里脑补拆分成子问题的过程，而是画出递归树，所有的递归都可以画出递归树。
              一旦画出递归树之后，是否存在重复子问题也变得一目了然

题目摘要：
    一维dp table:
        1. 零钱兑换 CoinChange: 介绍了暴力递归，带备忘录的递归，以及动态规划的不同解法和区别

        2.1 最长上升子序列 LengthOfLIS:介绍了带备忘录的递归，以及动态规划的不同解法和区别
        2.2 俄罗斯套娃信封问题 MaxEnvelopes:是最长上升子序列问题LengthOfLIS的加强版

        3.1 最大子序和MaxSubArray:当dp[i]的含义定义错时无法由dp[0...i-1]推出dp[i]的情况
        3.2 乘积最大子数组MaxProduct:大框架和3.1相似，但是需要处理一个负数问题

    二维dp table:
        两个字符串求各种各样子序列类型的题目：
            1.1 最长公共子序列LongestCommonSubsequence:介绍了暴力递归,带备忘录的递归,以及动态规划的不同解法和区别
            1.2 两个字符串的删除操作MinDistance:是最长公共子序列LongestCommonSubsequence同类型的题目,会前者就会MinDistance  介绍了暴力递归,带备忘录的递归,以及动态规划的不同解法
            1.3 两个字符串的最小ASCII删除和MinimumDeleteSum: 和两个字符串的删除操作MinDistance几乎是同一道题 但是在这道题里面介绍了两种动态规划的方法
            1.4 编辑距离Distance 和1.1 1.2 1.3同类型，只不过理解上比1.1 1.2 1.3困难一些 自己同样写了三种方法：暴力递归-->带备忘录的递归-->动态规划

            1.5 通配符匹配IsMatch44
            1.6 正则表达式匹配IsMatch10.在1.5更加困难

        一个字符串中的回文子序列类型题目：
            1.1 最长回文子序列LongestPalindromeSubseq: 只有指定的遍历顺序才可以将dp table顺利的填满

        62. 不同路径UniquePaths是一个dp数组倒着赋值的典型例题
